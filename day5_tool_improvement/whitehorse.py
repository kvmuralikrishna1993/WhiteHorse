import tkinter as tk
import os
import bcrypt
from tkinter import filedialog
from Crypto.Cipher import AES
from Crypto.Hash import SHA256
from Crypto import Random
from hashlib import sha256

#*****************************************************************
#Global variables
filename = ""
#********************************************************************

#Helper Funtions. 
#===============

#returning variables from the labels
#1.Path of file
#2.password entered
def get_path():
	return path_label.get()
	
def get_pass():
	return passwrd_label.get()

#Assigning new file name after encrypting data
def create_encrypt_name(filename_):
	l = len(filename_)
	temp = filename_[::-1]
	tl = temp.index("/")
	return filename_[0:(l-tl)]+"encrypted_"+filename_[(l-tl):len(filename_)]

#Assigning new file name after decrypting data
def create_decrypt_name(filename_):
	l = len(filename_)
	temp = filename_[::-1]
	tl = temp.index("/")
	return filename_[0:(l-tl)]+"decrypted_"+filename_[(l-tl):len(filename_)]

#Salt value is obtain from the predefined functions in python i.e; from bcrypt
# To generate new salt use generate function
# You can customize the salt.
# Hash generated by bcrypt length is 60 
# For AES purpose we digest it to 16 (AES key should be 16,24,32)
def get_key(Key):
	salt = b'$2b$12$221eTzU0zweNKfeX58oBcO' # generated random salt using bcrypt
	Key = bcrypt.hashpw(Key.encode('utf-8'), salt) #created a hash using bcrypt
	Key = sha256(Key).digest()[:16] #reduced to 16
	return Key

#This for selecting the file of different extensions.
def open_path():
	filename = filedialog.askopenfilename(initialdir = "/",title = "Select file",filetypes = (("png files","*.png"),("jpeg files","*.jpg"),("all files","*.*")))
	path_label.insert("insert", filename)

#***************************************************************

#GUI objects
root = tk.Tk()
root.title("`protector")
root.geometry("900x400") #You want the size of the app to be 500x500
root.resizable(0, 0)

#**************************************************************
#For the Name of Software. #WHITEHORSE
headframe  = tk.Frame(root,width=300, height=50, colormap="new")
head = tk.Label(headframe, text="WHITE^HOR$E",fg = "blue") #box2
head.config(font=("Courier", 44))
head.grid(row=0,column=0)
headframe.pack()

#**************************************************************
#Just left space for view
spaceframe1 = tk.Frame(root,width=400, height=50, colormap="new")
spaceframe1.pack()

#**************************************************************
#Frame for password and Browsing path of the file
topframe  = tk.Frame(root)
topframe.pack()

#Browse Button for selecting file
browsebutton = tk.Button(topframe, text = "Browse", fg = "blue", command= open_path)
browsebutton.config(height = 2, width = 10,font=('Courier', 20))
browsebutton.grid(row=0,column=0)

#Label showing to Enter password 
passwrd = tk.Label(topframe, text="Password",fg = "blue") #box2
passwrd.config(height = 2, width = 10,font=('Courier', 20))
passwrd.grid(row=1,column=0)

#Label for path entry
path_label = tk.Entry(topframe)
path_label.config(width = 50,bd =4,font=('Courier', 20))
path_label.grid(row=0, column=1)

#Label for password entry
passwrd_label = tk.Entry(topframe)
passwrd_label.config(width = 50,bd =4,show ="*",font=('Courier', 20))
passwrd_label.grid(row=1, column=1)

#****************************************************************
#For dialog sucessfull or failure.
spaceframe2 = tk.Frame(root,width=400, height=70, colormap="new")
spaceframe2.pack()

def error_clear(alert):
	alert['text'] = ""
#***************************************************************
#Encrypting data here
def encrypt():
	try:
		filename_ = get_path()
		Key = get_pass()
		print(len(filename_))
		print(len(Key))
		if(len(filename_) < 3 or len(Key) <= 5):
			#error
			alert = tk.Label(spaceframe2, text="**Enter the valid path or Enter the valid password**",fg = "red")
			alert.config(font=("Courier", 24))
			alert.grid(row=0,column=0)
			spaceframe2.pack()
		else:
			blocksize = 64*1024
			outputFile = create_encrypt_name(filename_)
			filesize = str(os.path.getsize(filename_)).zfill(16)
			Key = get_key(Key)
			IV = Random.new().read(16)
			encryptor = AES.new(Key,AES.MODE_CBC, IV)
			with open(filename_, 'rb') as infile:
				with open(outputFile, 'wb') as outfile: #writing output file as binary
					outfile.write(filesize.encode('utf-8')) #encoding filesize utf -8
					outfile.write(IV) #writing intialised vector
					while True:
						block = infile.read(blocksize) # reading each block
						if len(block) == 0: #all blocks completed we stop operation
							break
						elif len(block) % 16 != 0: # if block is not equal to 16 bytes then we add padding so that it will be 16 by 
							block += b'}' * (16 - (len(block) % 16)) #16- 15%16 ==> 1
						outfile.write(encryptor.encrypt(block)) # encrypt and write the file.	
			#error
			alert = tk.Label(spaceframe2, text="")
			alert.grid(row=0,column=0)
			spaceframe2.pack()
			error_clear(alert)
			alert = tk.Label(spaceframe2, text="**Encryption Successful**",fg = "red")
			alert.config(font=("Courier", 24))
			alert.grid(row=0,column=0)
			spaceframe2.pack()
	except Exception as e:
		#error
		alert = tk.Label(spaceframe2, text="")
		alert.grid(row=0,column=0)
		spaceframe2.pack()
		error_clear(alert)
		alert = tk.Label(spaceframe2, text="**Error Occurred.Encryption Unsuccessful**",fg = "red")
		alert.config(font=("Courier", 24))
		alert.grid(row=0,column=0)
		spaceframe2.pack()
	finally:
		path_label.insert("insert", "")
		passwrd_label.insert("insert", "")

#****************************************************************
#Decrypting data
def decrypt():
	try:
		filename_ = get_path()
		Key = get_pass()
		if(len(filename_) < 3 or len(Key) <= 5):
			#error
			alert = tk.Label(spaceframe2, text="**Enter the valid path or Enter the valid password**",fg = "red")
			alert.config(font=("Courier", 24))
			alert.grid(row=0,column=0)
			spaceframe2.pack()
		else:
			blocksize = 64*1024
			outputFile = create_decrypt_name(filename_)
			Key = get_key(Key)
			with open(filename_,'rb') as infile:
				size  = infile.read(16) # first 16 bytes length of file size
				filesize = size.decode()
				IV = infile.read(16)
				decryptor = AES.new(Key, AES.MODE_CBC, IV)
				with open(outputFile,'wb') as outfile:
					while True:
						block = infile.read(blocksize)
						if(len(block) == 0):
							break
						outfile.write(decryptor.decrypt(block))
					outfile.truncate(int(filesize))
			#error
			error_clear(alert)
			alert = tk.Label(spaceframe2, text="**Decryption Successful**",fg = "red")
			alert.config(font=("Courier", 24))
			alert.grid(row=0,column=0)
			spaceframe2.pack()
	except Exception as e:
		#error
		error_clear(alert)
		alert = tk.Label(spaceframe2, text="**Error Occurred.Decryption Unsuccessful**",fg = "red")
		alert.config(font=("Courier", 24))
		alert.grid(row=0,column=0)
		spaceframe2.pack()
	finally:
		path_label.insert("insert", "")
		passwrd_label.insert("insert", "")
#*****************************************************************
#Buttons
bottomframe = tk.Frame(root)
bottomframe.pack()

#encryption buttons
button_encrypter = tk.Button(bottomframe,text = "Encrypt", fg = "red",command= encrypt)
button_encrypter.pack(side = "left", padx =50)
button_encrypter.config(height = 3, width = 10,font=('Courier', 20))

#decryption buttons
button_decrypter = tk.Button(bottomframe,text = "Decrypt", fg = "green",command= decrypt)
button_decrypter.pack(side = "left", padx=50)
button_decrypter.config(height = 3, width = 10,font=('Courier', 20))

if __name__ == '__main__':
	root.mainloop()